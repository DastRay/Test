#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <variant>
#include <stdexcept>
#include <iomanip>
#include <cctype>
#include <cstring>

// ==================== Часть 1. Класс MultiSet (как в "пока.txt") ====================

#pragma once
#include <iostream>
#include <locale.h>

#include <fstream>
#include <string>
#include <stdexcept>
using namespace std;


/**
 * @brief Вычисляет длину строки.
 *
 * Алгоритм:
 * 1. Инициализирует переменную `length` для хранения длины строки.
 * 2. Проходит по строке, увеличивая счетчик `length` до тех пор, пока не
        встретит символ конца строки `\0`.
 * 3. Возвращает полученную длину строки.
 *
 * @param str Указатель на строку, длину которой необходимо вычислить.
 * @return Длину строки без учета символа конца строки `\0`.
 */




size_t my_strlen(const char* str) {
   size_t length = 0;

   // Проходим по строке, пока не
   // встретим символ конца строки '\0'
   while (str[length] != '\0') {
      ++length;
   }

   return length;                           // Возвращаем длину строки
}




/**
 * @brief Копирует строку из источника (src) в назначение (dest).
 *
 * Алгоритм:
 * 1. Сохраняет указатель на начало строки назначения (`original_dest`).
 * 2. Копирует символы из строки-источника в строку-назначение по одному символу.
 *    - Используется цикл с условием `(*dest++ = *src++)`, который выполняется,
 *      пока символ из источника успешно копируется (включая '\0').
 * 3. Возвращает указатель на начало строки назначения.
 *
 * @param dest Указатель на массив, куда будет копирована строка.
 * @param src Указатель на исходную строку, которая будет копирована.
 * @return Указатель на начало строки назначения (`dest`).
 */




char* my_strcpy(char* dest, const char* src) {
   char* original_dest = dest;                         // Сохраняем указатель на начало строки назначения

   // Копируем символы из src в dest,
   // пока не встретится нулевой символ
   while ((*dest++ = *src++));

   return original_dest;                                // Возвращаем указатель на строку назначения
}



/**
 * @brief Класс исключения для обработки некорректных символов.
 *
 * Этот класс используется для создания исключения, если обнаруживается некорректный символ.
 * В сообщении исключения указывается сам символ и описание ошибки.
 */




class InvalidCharacterException {
public:




   /**
    * @brief Конструктор, инициализирующий исключение с указанием некорректного символа.
    *
    * Алгоритм:
    * 1. Формирует базовое сообщение "Некорректный символ: ".
    * 2. Проверяет, достаточно ли места в буфере `message_` для полного сообщения
    *    (включая базовое сообщение, символ, и завершающий `'\0'`).
    * 3. Если места достаточно, дополняет сообщение некорректным символом.
    * 4. Если места недостаточно, сохраняет только базовое сообщение.
    *
    * @param invalid_char Символ, который вызвал исключение.
    */




   explicit InvalidCharacterException(char invalid_char) {
      const char* base_message = "Некорректный символ: ";
      size_t base_length = my_strlen(base_message);

      // Проверка на вместимость сообщения в буфер
      if (base_length + 2 < sizeof(message_)) {               // +2: один символ + '\0'
         my_strcpy(message_, base_message);                 // Копируем базовое сообщение
         message_[base_length] = invalid_char;               // Добавляем некорректный символ
         message_[base_length + 1] = '\0';                    // Завершаем строку
      }
      else {
         my_strcpy(message_, base_message);                  // Если не хватает места, только базовое сообщение
      }
   }




   /**
    * @brief Возвращает сообщение об ошибке.
    *
    * @return Указатель на строку с сообщением об ошибке.
    */




   const char* what() const noexcept {
      return message_;
   }

private:
   char message_[256];                                     ///< Буфер для хранения сообщения об ошибке.
};




/**
 * @brief Класс исключения для обработки ошибки отсутствия открывающей фигурной скобки.
 *
 * Этот класс используется для генерации исключения, если в вводе отсутствует
 * ожидаемая открывающая фигурная скобка `{`. В сообщение можно добавить
 * дополнительные подробности о контексте ошибки.
 */




class MissingOpeningBraceException {
public:




   /**
    * @brief Конструктор исключения с возможностью указать дополнительные подробности.
    *
    * Алгоритм:
    * 1. Инициализирует базовое сообщение "Ошибка формата ввода: отсутствует '{' ".
    * 2. Вычисляет длины базового сообщения и дополнительной информации (`details`).
    * 3. Проверяет, достаточно ли места в буфере `message_` для хранения полного сообщения.
    *    - Если места достаточно, копирует базовое сообщение и добавляет подробности.
    *    - Если места недостаточно, сохраняет только базовое сообщение.
    *
    * @param details Дополнительные сведения о контексте ошибки (по умолчанию пустая строка).
    */




   explicit MissingOpeningBraceException(const char* details = "") {
      const char* base_message = "Ошибка формата ввода: отсутствует '{' ";
      size_t base_length = my_strlen(base_message);
      size_t details_length = my_strlen(details);


      if (base_length + details_length < sizeof(message_)) {
         my_strcpy(message_, base_message);
         my_strcpy(message_ + base_length, details);
      }
      else {

         my_strcpy(message_, base_message);
      }
   }




   /**
    * @brief Возвращает сообщение об ошибке.
    *
    * @return Указатель на строку с сообщением об ошибке.
    */




   const char* what() const noexcept {
      return message_;
   }

private:
   char message_[256]; ///< Буфер фиксированного размера для хранения сообщения об ошибке.
};




/**
 * @brief Класс исключения для обработки выхода
         индекса за пределы допустимого диапазона.
 *
 * Это исключение используется для сигнализации о попытке доступа к элементу
 * по индексу, превышающему размер массива или коллекции.
 */




class IndexOutOfBoundsException : public std::exception {
public:




   /**
    * @brief Конструктор, инициализирующий данные об индексе и размере массива.
    *
    * @param index Проблемный индекс, который вызвал исключение.
    * @param size Размер массива или коллекции, для которой произошла ошибка.
    */




   IndexOutOfBoundsException(size_t index, size_t size)
      : index_(index), size_(size) {
   }




   /**
    * @brief Метод для получения сообщения об ошибке.
    *
    * Переопределяет метод `what()` из базового класса `std::exception`.
    *
    * @return Указатель на строку с сообщением об ошибке.
    */


   const char* what() const noexcept override {
      return "Ошибка: индекс выходит за пределы допустимого диапазона!";
   }

   /**
    * @brief Получение проблемного индекса.
    *
    * @return Значение индекса, вызвавшего ошибку.
    */



   size_t getIndex() const {
      return index_;
   }

   /**
    * @brief Получение размера массива или коллекции.
    *
    * @return Размер массива или коллекции, связанный с ошибкой.
    */


   size_t getSize() const {
      return size_;
   }

private:
   size_t index_; ///< Индекс, который выходит за пределы диапазона.
   size_t size_;  ///< Размер массива или коллекции, с которым сравнивается индекс.
};




/**
 * @brief Класс исключения для обработки ошибок выделения памяти.
 *
 * Это исключение используется для сигнализации о сбоях при попытке выделения памяти.
 * Наследуется от `std::exception` для интеграции со стандартной системой обработки исключений в C++.
 */




class MemoryException : public std::exception {
public:




   /**
    * @brief Метод для получения сообщения об ошибке.
    *
    * Переопределяет метод `what()` из базового класса `std::exception`.
    *
    * @return Указатель на строку с сообщением об ошибке.
    */


   const char* what() const noexcept override {
      return "Ошибка выделения памяти!";
   }
};



/**
 * @brief Класс исключения для ошибки превышения размера множества над емкостью.
 *
 * Это исключение сигнализирует о попытке добавить элементы в множество,
 * когда его текущий размер уже достиг максимальной емкости.
 * Наследуется от `std::exception` для совместимости со стандартной системой исключений C++.
 */




class CapacityExceededException : public std::exception {
public:




   /**
    * @brief Метод для получения сообщения об ошибке.
    *
    * Переопределяет метод `what()` из базового класса `std::exception`.
    *
    * @return Указатель на строку с сообщением об ошибке.
    */


   const char* what() const noexcept override {
      return "Ошибка: размер множества превышает емкость!";
   }
};



class MultiSet
{
private:
   int* elements;                                    // Массив элементов
   size_t size;                                    // Текущий размер множества
   size_t capacity;                                // Емкость массива

   static const int RUN = 32;








   /**
* @brief Увеличивает емкость массива при необходимости.
*
* Если текущий размер массива (`size`) достиг емкости (`capacity`), метод увеличивает
* емкость в два раза, выделяет новую область памяти, копирует элементы из старой области
* в новую и обновляет указатель на массив. Если выделение памяти не удается, выбрасывается
* исключение `MemoryException`.
*
* Алгоритм:
* 1. Проверяем, достиг ли размер массива текущей емкости.
* 2. Если емкость равна нулю, устанавливаем ее в 1. Иначе удваиваем емкость.
* 3. Выделяем новую область памяти под увеличенный массив.
* 4. Если выделение не удалось, выбрасываем `MemoryException`.
* 5. Копируем элементы из старого массива в новый.
* 6. Освобождаем память старого массива.
* 7. Обновляем указатель на массив и емкость.
*/




   void ensure_capacity() {
      // Проверяем, нужно ли
      // увеличивать емкость
      if (size >= capacity) {
         // Если емкость равна 0, 
         // устанавливаем её в 1
         if (capacity == 0)
            capacity = 1;
         else
            capacity *= 2;                                                   // Увеличиваем емкость вдвое

         // Выделяем новый массив 
         // с увеличенной емкостью
         int* new_elements = new (std::nothrow) int[capacity];
         if (!new_elements) {
            throw MemoryException();                                        // Выбрасываем исключение при ошибке выделения памяти
         }

         // Копируем элементы 
         // из старого массива в новый
         for (size_t i = 0; i < size; ++i) {
            new_elements[i] = elements[i];
         }

         // Освобождаем память,
         // занимаемую старым массивом
         delete[] elements;

         // Обновляем указатель на 
         // новый массив
         elements = new_elements;
      }
   }



   //сортировки вставками
   void insertion_sort(int* arr, size_t left, size_t right)
   {
      for (size_t i = left + 1; i <= right; i++)
      {
         int temp = arr[i];
         size_t j = i - 1;
         while (j >= left && arr[j] > temp)
         {
            arr[j + 1] = arr[j];
            if (j-- == 0) break; // Защита от переполнения
         }
         arr[j + 1] = temp;
      }
   }
   // сортировка слиянием
   void merge(int* arr, size_t l, size_t m, size_t r)
   {
      size_t len1 = m - l + 1, len2 = r - m;
      int* left = new int[len1];
      int* right = new int[len2];

      for (size_t i = 0; i < len1; i++) left[i] = arr[l + i];
      for (size_t i = 0; i < len2; i++) right[i] = arr[m + 1 + i];

      size_t i = 0, j = 0, k = l;
      while (i < len1 && j < len2)
      {
         if (left[i] <= right[j])
         {
            arr[k++] = left[i++];
         }
         else
         {
            arr[k++] = right[j++];
         }
      }

      while (i < len1) arr[k++] = left[i++];
      while (j < len2) arr[k++] = right[j++];

      delete[] left;
      delete[] right;
   }

   void timsort()
   {
      for (size_t i = 0; i < size; i += RUN)
      {
         insertion_sort(elements, i, (i + RUN - 1 < size ? i + RUN - 1 : size - 1));
      }

      for (size_t width = RUN; width < size; width *= 2)
      {
         for (size_t left = 0; left < size; left += 2 * width)
         {
            size_t mid = left + width - 1;
            size_t right = (left + 2 * width - 1 < size ? left + 2 * width - 1 : size - 1);

            if (mid < right)
            {
               merge(elements, left, mid, right);
            }
         }
      }
   }



   /**
* @brief Подсчитывает частоты элементов массива и находит максимальный элемент.
*
* Метод проходит по массиву и выполняет следующие действия:
* 1. Если массив `freq` передан (не равен `nullptr`), увеличивает значение частоты
*    для текущего элемента `elements[i]` в массиве частот.
* 2. Обновляет значение `max_elem`, если текущий элемент больше текущего максимума.
*
* @param freq Указатель на массив частот (должен быть предварительно инициализирован).
*             Если равен `nullptr`, частоты не подсчитываются.
* @param max_elem Ссылка на переменную для хранения максимального элемента массива.
*/




   void count_frequencies(int* freq, int& max_elem) const {
      for (size_t i = 0; i < size; ++i) {
         // Увеличиваем частоту текущего
         // элемента, если массив частот
         // задан
         if (freq) {
            freq[elements[i]]++;
         }
         // Обновляем максимальный элемент
         if (elements[i] > max_elem) {
            max_elem = elements[i];
         }
      }
   }




   // Собственная реализация функции my_max
   int my_max(int a, int b) const {
      return (a > b) ? a : b;
   }

   // Собственная реализация функции my_min
   int my_min(int a, int b) const {
      return (a < b) ? a : b;
   }


public:


   // Метод для чтения данных из файла с выводом для отладки
   void readFromFile(std::ifstream& file) {
      // std::cout << "Начинаем читать из файла..." << std::endl;

       // Проверка, открыт ли файл
      if (!file.is_open()) {
         throw std::runtime_error("Не удалось открыть файл.");
      }

      clear(); // Очищаем текущее множество перед загрузкой
      // std::cout << "Текущее множество очищено." << std::endl;

      char ch;
      file >> ch; // Считываем первый символ
      // std::cout << "Считан символ: " << ch << std::endl;

      if (ch != '{') {
         throw MissingOpeningBraceException("в начале файла.");
      }

      file >> std::ws; // Пропускаем пробелы и символы новой строки
      //std::cout << "Пропускаем пробелы и символы новой строки." << std::endl;

      if (file.peek() == '}') {
         file.get(); // Считываем '}'
         //    std::cout << "Файл содержит пустое множество." << std::endl;
         return; // Пустое множество
      }

      while (true) {
         int num;
         if (!(file >> num)) {
            throw std::runtime_error("Ошибка чтения числа из файла.");
         }

         //   std::cout << "Считано число: " << num << std::endl;
         add(num);

         file >> std::ws; // Пропускаем пробелы и символы новой строки
         //   std::cout << "Пропускаем пробелы после числа." << std::endl;

         char next = file.peek(); // Получаем следующий символ без извлечения
         //   std::cout << "Следующий символ: " << next << std::endl;

         if (next == '}') {
            file.get(); // Считываем '}'
            //       std::cout << "Конец множества, считываем '}'. Завершаем." << std::endl;
            break;
         }
         else if (!isdigit(next) && next != '-' && next != '+') {
            file.get(); // Считываем текущий символ
            throw InvalidCharacterException(next);
         }
      }

      timsort(); // Сортируем множество после загрузки
      // std::cout << "Множество отсортировано." << std::endl;
   }



   // Оператор для использования в std::map
   bool operator<(const MultiSet& other) const {
      size_t minSize = (size < other.size) ? size : other.size;

      // Лексикографическое сравнение элементов
      for (size_t i = 0; i < minSize; ++i) {
         if (elements[i] < other.elements[i]) return true;
         if (elements[i] > other.elements[i]) return false;
      }

      // Если все общие элементы равны, меньшее множество имеет меньший размер
      return size < other.size;
   }




   /**
 * @brief Конструктор по умолчанию для класса MultiSet.
 *
 * Инициализирует пустое множество с начальной емкостью.
 * - Размер множества (`size`) изначально равен 0.
 * - Емкость множества (`capacity`) установлена в 10.
 * - Выделяет динамическую память для хранения элементов множества.
 *
 * Если выделение памяти не удаётся, выбрасывается исключение `MemoryException`.
 *
 * @throws MemoryException Если память не может быть выделена.
 */




   MultiSet()
   {
      size = 0;                                       // Начальный размер множества - пустое множество
      capacity = 1000;                                   // Начальная емкость множества
      elements = new int[capacity];                   // Выделение памяти под массив

      // Проверяем, успешно ли выделена память
      if (!elements)
      {
         throw MemoryException();                    // Исключение при ошибке выделения памяти
      }
   }




   /**
 * @brief Конструктор для создания множества из массива.
 *
 * Этот конструктор инициализирует множество на основе переданного массива.
 * - Устанавливает размер множества (`size`) равным количеству элементов в переданном массиве.
 * - Емкость массива устанавливается в два раза больше размера множества, чтобы предусмотреть расширение.
 * - Выделяет память под массив элементов множества.
 * - Копирует элементы из переданного массива в новый массив.
 * - После копирования сортирует элементы множества с помощью алгоритма сортировки `timsort`.
 *
 * @param elems Указатель на массив элементов, из которых будет создано множество.
 * @param count Количество элементов в переданном массиве.
 * @throws MemoryException Если память не может быть выделена.
 */




   MultiSet(const int* elems, size_t count) {
      size = count;                                   // Устанавливаем размер множества равным количеству элементов
      capacity = count * 2;                            // Устанавливаем емкость массива с запасом (в два раза больше размера)
      elements = new int[capacity];                    // Выделяем память под массив элементов

      // Проверяем успешность выделения памяти
      if (!elements) {
         throw MemoryException();                     // Выбрасываем исключение, если память не выделена
      }

      // Копируем элементы из переданного массива в новый массив
      for (size_t i = 0; i < count; ++i) {
         elements[i] = elems[i];
      }

      // Сортируем элементы множества с использованием алгоритма timsort
      timsort();
   }





   /**
* @brief Конструктор копирования для множества.
*
* Этот конструктор создает новое множество, копируя все данные из другого множества.
* - Копирует размер множества (`size`) и емкость массива (`capacity`).
* - Выделяет память для нового массива элементов.
* - Копирует все элементы из массива другого множества в новый массив.
*
* @param other Ссылка на другое множество, из которого копируются данные.
* @throws MemoryException Если память не может быть выделена.
*/




   MultiSet(const MultiSet& other) {
      // Копируем текущий размер множества
      size = other.size;

      // Копируем емкость массива
      capacity = other.capacity;

      // Выделяем память для нового массива элементов
      elements = new int[capacity];
      if (!elements) {
         throw MemoryException();            // Выбрасываем исключение, если память не выделена
      }

      // Копируем элементы из существующего множества
      for (size_t i = 0; i < size; ++i) {
         elements[i] = other.elements[i];
      }
   }



   ~MultiSet() {
      delete[] elements;
   }



   /**
* @brief Оператор присваивания для множества.
*
* Этот оператор копирует все данные из одного множества в другое, при этом:
* - Проверяется, что объект не присваивает сам себе.
* - При необходимости освобождается память, выделенная для элементов текущего множества.
* - Выделяется новая память для элементов.
* - Копируются данные (размер, емкость и элементы) из другого множества.
*
* @param other Ссылка на множество, из которого копируются данные.
* @return Ссылка на текущий объект, после присваивания.
* @throws CapacityExceededException Если размер множества больше его емкости.
* @throws MemoryException Если не удалось выделить память.
*/




   MultiSet& operator=(const MultiSet& other)
   {
      // Проверка на самоприсваивание
      if (this != &other)
      {
         // Проверка на превышение емкости множества
         if (other.size > other.capacity)
         {
            throw CapacityExceededException();
         }

         // Освобождаем старую память
         delete[] elements;

         // Выделяем новую память для
         // элементов с емкостью другого множества
         elements = new int[other.capacity];
         if (!elements)
         {
            throw MemoryException();
         }

         // Копируем параметры (размер и емкость)
         size = other.size;
         capacity = other.capacity;

         // Копируем элементы из другого множества
         for (size_t i = 0; i < size; ++i) {
            elements[i] = other.elements[i];
         }
      }

      // Возвращаем текущий объект
      return *this;
   }



   void add(int value)
   {
      ensure_capacity();
      elements[size++] = value;                                   // Просто добавляем в конец
   }



   /**
* @brief Перегрузка оператора сложения для множества.
*
* Оператор `+` объединяет два множества, создавая новое множество,
* которое содержит элементы из обоих исходных множеств.
* При этом для каждого элемента выбирается наибольшая частота его появления
* из обоих множеств, чтобы сформировать результат.
*
* Алгоритм:
* 1. Сначала подсчитывается максимальный элемент в каждом множестве для определения необходимого размера массивов частот.
* 2. Выделяется память для хранения частот элементов каждого множества.
* 3. Подсчитываются частоты элементов в обоих множествах.
* 4. Создается новое множество, элементы которого добавляются с максимальной частотой из двух исходных.
* 5. Освобождается память, выделенная для массивов частот.
*
* @param other Второе множество, с которым будет производиться объединение.
* @return MultiSet Новый объект множества, являющийся результатом объединения двух множеств.
*/




   MultiSet operator+(const MultiSet& other) const
   {

      int max_elem1 = 0, max_elem2 = 0;
      count_frequencies(nullptr, max_elem1);
      other.count_frequencies(nullptr, max_elem2);


      int max_elem = my_max(max_elem1, max_elem2);


      int* freq1 = new int[max_elem + 1]();
      int* freq2 = new int[max_elem + 1]();


      count_frequencies(freq1, max_elem1);
      other.count_frequencies(freq2, max_elem2);


      MultiSet result;


      for (int i = 1; i <= max_elem; ++i)
      {
         int count = my_max(freq1[i], freq2[i]);
         for (int j = 0; j < count; ++j)
         {
            result.add(i);
         }
      }


      delete[] freq1;
      delete[] freq2;


      return result;
   }






   /**
* @brief Перегрузка оператора умножения для множества.
*
* Оператор `*` пересекает два множества, создавая новое множество,
* которое содержит элементы, встречающиеся в обоих множествах.
* При этом для каждого элемента выбирается наименьшая частота его появления
* из двух множеств, чтобы сформировать результат.
*
* Алгоритм:
* 1. Сначала подсчитывается максимальный элемент в каждом множестве для определения
       необходимого размера массивов частот.
* 2. Выделяется память для хранения частот элементов каждого множества.
* 3. Подсчитываются частоты элементов в обоих множествах.
* 4. Создается новое множество, элементы которого добавляются с наименьшей частотой из двух исходных.
* 5. Освобождается память, выделенная для массивов частот.
*
* @param other Второе множество, с которым будет производиться пересечение.
* @return MultiSet Новый объект множества, являющийся результатом пересечения двух множеств.
*/




   MultiSet operator*(const MultiSet& other) const
   {

      int max_elem1 = 0, max_elem2 = 0;
      count_frequencies(nullptr, max_elem1);
      other.count_frequencies(nullptr, max_elem2);


      int max_elem = my_max(max_elem1, max_elem2);


      int* freq1 = new int[max_elem + 1]();
      int* freq2 = new int[max_elem + 1]();


      count_frequencies(freq1, max_elem1);            // Подсчёт частот для текущего множества
      other.count_frequencies(freq2, max_elem2);      // Подсчёт частот для другого множества

      // Создаем результатирующее множество.
      MultiSet result;


      for (int i = 1; i <= max_elem; ++i)
      {

         int count = my_min(freq1[i], freq2[i]);
         for (int j = 0; j < count; ++j)
         {
            result.add(i);                          // Добавляем элемент в результирующее множество
         }
      }


      delete[] freq1;
      delete[] freq2;


      return result;
   }





   /**
 * @brief Перегрузка оператора вычитания для множества.
 *
 * Оператор `-` вычитает элементы одного множества из другого, создавая новое множество,
 * которое содержит элементы первого множества, но без элементов, присутствующих во втором множестве.
 * При этом учитываются их частоты: если элемент встречается несколько раз в первом множестве и
 * хотя бы один раз во втором, то соответствующая частота в результате уменьшается.
 *
 * Алгоритм:
 * 1. Подсчитывается максимальный элемент в каждом из множеств для определения необходимого размера массивов частот.
 * 2. Выделяется память для хранения частот элементов обоих множеств.
 * 3. Подсчитываются частоты элементов в обоих множествах.
 * 4. Создается новое множество, в которое добавляются элементы первого множества с учётом вычитания частоты во втором множестве.
 * 5. Освобождается память, выделенная для массивов частот.
 *
 * @param other Второе множество, из которого будут вычитаться элементы первого множества.
 * @return MultiSet Новый объект множества, являющийся результатом вычитания элементов.
 */




   MultiSet operator-(const MultiSet& other) const
   {

      int max_elem1 = 0, max_elem2 = 0;
      count_frequencies(nullptr, max_elem1);
      other.count_frequencies(nullptr, max_elem2);


      int max_elem = my_max(max_elem1, max_elem2);


      int* freq1 = new int[max_elem + 1]();
      int* freq2 = new int[max_elem + 1]();


      count_frequencies(freq1, max_elem1);
      other.count_frequencies(freq2, max_elem2);


      MultiSet result;

      for (int i = 1; i <= max_elem; ++i)
      {
         int count = freq1[i] - freq2[i];

         if (count > 0)
         {
            for (int j = 0; j < count; ++j)
            {
               result.add(i);
            }
         }
      }

      delete[] freq1;
      delete[] freq2;

      return result;
   }


   void clear()
   {
      size = 0;
   }


   /**
* @brief Перегрузка оператора симметрической разности для множества.
*
* Оператор `^` реализует операцию симметрической разности между двумя множествами.
* Симметрическая разность включает в себя элементы, которые принадлежат только одному из множеств,
* но не оба. То есть, это объединение двух множеств, из которого исключены общие элементы (пересечение).
*
* Алгоритм:
* 1. Сначала выполняется операция объединения (`*this + other`), которая включает все элементы из обоих множеств.
* 2. Затем из результата вычитания вычитается пересечение множеств (`*this * other`), чтобы исключить элементы, которые встречаются в обоих множествах.
* 3. В результате получается множество, содержащее только те элементы, которые есть в одном из множеств, но не в обоих.
*
* @param other Второе множество, с которым будет вычисляться симметрическая разность.
* @return MultiSet Новый объект множества, являющийся результатом симметрической разности.
*/



   MultiSet operator^(const MultiSet& other) const
   {
      return (*this + other) - (*this * other);
   }



   int getSize()
   {
      return size;
   }


   /**
* @brief Перегрузка оператора доступа по индексу для множества.
*
* Оператор `[]` позволяет получить элемент множества по индексу.
* Если индекс выходит за пределы допустимого диапазона (меньше 0 или больше или равен размеру множества),
* то выбрасывается исключение `IndexOutOfBoundsException`.
*
* Алгоритм:
* 1. Проверяем, не выходит ли индекс за пределы множества. Если индекс больше или равен текущему размеру множества,
*    выбрасываем исключение `IndexOutOfBoundsException` с указанием некорректного индекса и размера множества.
* 2. Если индекс валиден, возвращаем элемент массива по соответствующему индексу.
*
* @param index Индекс, по которому требуется получить элемент.
* @return int Элемент множества, расположенный по указанному индексу.
* @throws IndexOutOfBoundsException Исключение, если индекс выходит за пределы допустимого диапазона.
*/



   int operator[](size_t index) const
   {
      // Проверка на выход индекса
      // за пределы множества
      if (index >= size)
      {
         throw IndexOutOfBoundsException(index, size);           // Выбрасываем исключение
      }
      return elements[index];                                     // Возвращаем элемент по индексу
   }




   /**
 * @brief Перегрузка оператора сравнения `==` для множества.
 *
 * Оператор `==` проверяет, равны ли два множества. Множества считаются равными, если:
 * 1. У них одинаковый размер.
 * 2. Все элементы в одном множестве равны соответствующим элементам в другом множестве,
           при этом порядок элементов должен совпадать.
 *
 * Алгоритм:
 * 1. Сравниваем размеры множеств. Если размеры не равны, множества не равны, и возвращаем `false`.
 * 2. Если размеры одинаковые, то последовательно сравниваем каждый элемент множества.
           Если хотя бы один элемент отличается, возвращаем `false`.
 * 3. Если все элементы совпали, множества равны и возвращаем `true`.
 *
 * @param other Множество, с которым выполняется сравнение.
 * @return true, если множества равны, иначе false.
 */




   bool operator==(const MultiSet& other) const
   {
      // Сравнение размеров множеств
      if (size != other.size) return false;               // Множества не равны, если размеры разные

      // Сравнение элементов множества по очереди
      for (size_t i = 0; i < size; ++i)
      {
         if (elements[i] != other.elements[i]) return false;
      }

      return true;                                        // Если все элементы совпали, множества равны
   }




   bool operator!=(const MultiSet& other) const
   {
      return !(*this == other); // Если множества равны, возвращаем false, иначе true
   }





   /**
  * @brief Вставка элемента в отсортированное множество.
  *
  * Функция добавляет новый элемент в отсортированное множество, сохраняя порядок.
  * Используется бинарный поиск для нахождения позиции, куда должен быть вставлен элемент.
  *
  * @param value Элемент, который необходимо добавить в множество.
  */
   void add_First(int value) {
      ensure_capacity(); // Проверка и обеспечение достаточного объема памяти для нового элемента.

      int left = 0, right = size - 1; // Инициализация левой и правой границы для бинарного поиска.
      int insert_pos = size; // По умолчанию вставляем в конец массива, если элемент не найден.

      // Бинарный поиск для нахождения позиции вставки.
      while (left <= right) {
         int mid = left + (right - left) / 2; // Находим средний индекс.

         if (elements[mid] == value) {
            return; // Если элемент уже существует в множестве, ничего не добавляем.
         }
         else if (elements[mid] < value) {
            left = mid + 1; // Если средний элемент меньше значения, сужаем поиск к правой части массива.
         }
         else {
            right = mid - 1; // Если средний элемент больше значения, сужаем поиск к левой части массива.
            insert_pos = mid; // Запоминаем позицию для вставки элемента.
         }
      }

      // Сдвиг всех элементов, начиная с позиции insert_pos, вправо для освобождения места для нового элемента.
      memmove(&elements[insert_pos + 1], &elements[insert_pos], (size - insert_pos) * sizeof(int));

      // Вставка нового элемента на найденную позицию.
      elements[insert_pos] = value;

      ++size; // Увеличиваем размер множества после добавления нового элемента.
   }

   /**
    * @brief Проверка на наличие элемента в множестве.
    *
    * Функция выполняет бинарный поиск, чтобы проверить, содержится ли заданный элемент в множестве.
    *
    * @param value Элемент, наличие которого нужно проверить в множестве.
    * @return true, если элемент найден в множестве, иначе false.
    */
   bool contains(int value) const {
      int left = 0, right = size - 1; // Инициализация левой и правой границы для бинарного поиска.

      // Бинарный поиск элемента в отсортированном массиве.
      while (left <= right) {
         int mid = left + (right - left) / 2; // Находим средний индекс.

         if (elements[mid] == value) {
            return true; // Если элемент найден, возвращаем true.
         }
         else if (elements[mid] < value) {
            left = mid + 1; // Если элемент в середине меньше искомого, ищем в правой части.
         }
         else {
            right = mid - 1; // Если элемент в середине больше искомого, ищем в левой части.
         }
      }

      return false; // Если элемент не найден, возвращаем false.
   }

   /**
    * @brief Добавление первого отсутствующего элемента в множество.
    *
    * Функция находит первый отсутствующий положительный элемент и добавляет его в множество.
    * Для этого используется метод contains для поиска каждого числа, начиная с 1.
    */
   void addFirstMissing() {
      int current = 1; // Начинаем с первого возможного отсутствующего числа.

      while (true) {
         if (!contains(current)) { // Если текущий элемент отсутствует в множестве.
            add_First(current); // Добавляем его в множество.
            break; // Прерываем цикл после добавления первого отсутствующего элемента.
         }
         ++current; // Если элемент найден, переходим к следующему числу.
      }
   }





   // Итератор
   class Iterator
   {
   private:
      int* ptr;
   public:
      Iterator(int* ptr) : ptr(ptr) {}

      // Операция разыменования
      int& operator*()
      {
         return *ptr;
      }

      // Операция получения указателя на элемент
      int* operator->()
      {
         return ptr;
      }

      // Операция инкремента (движение итератора вперед)
      Iterator& operator++()
      {
         ++ptr;
         return *this;
      }

      // Операция декремента (движение итератора назад)
      Iterator& operator--()
      {
         --ptr;
         return *this;
      }

      // Операция сравнения
      bool operator!=(const Iterator& other) const
      {
         return ptr != other.ptr;
      }

      bool operator==(const Iterator& other) const
      {
         return ptr == other.ptr;
      }
   };

   // Метод для получения итератора на первый элемент
   Iterator begin()
   {
      return Iterator(elements);
   }

   // Метод для получения итератора на элемент после последнего
   Iterator end()
   {
      return Iterator(elements + size);
   }

   // Метод для получения итератора на элемент перед первым
   Iterator rbegin()
   {
      return Iterator(elements + size - 1);
   }

   // Метод для получения итератора на элемент перед первым (по аналогии с end для обычных итераторов)
   Iterator rend()
   {
      return Iterator(elements - 1);
   }


   /**
 * @brief Перегрузка оператора вывода для множества.
 *
 * Этот оператор позволяет вывести содержимое объекта типа MultiSet в поток вывода (например, в консоль).
 * Элементы множества выводятся внутри фигурных скобок `{}`, разделенные пробелами.
 *
 * @param os Поток вывода, в который будет записано множество.
 * @param ms Объект множества, содержимое которого будет выведено.
 *
 * @return os Обновленный поток вывода.
 */




   friend ostream& operator<<(ostream& os, const MultiSet& ms)
   {
      os << "{";                                      // Начинаем вывод с открывающей фигурной скобки
      for (size_t i = 0; i < ms.size; ++i)
      {
         os << ms.elements[i];                       // Выводим текущий элемент множества
         if (i < ms.size - 1)
            os << " ";
      }
      os << "}";                                       // Закрываем фигурные скобки

      return os;                                          // Возвращаем поток для дальнейших операций вывода
   }



   /**
* @brief Перегрузка оператора ввода для множества.
*
* Этот оператор позволяет вводить элементы множества `MultiSet` из потока ввода (например, с консоли).
* Ожидается, что элементы множества будут записаны в виде чисел, разделенных пробелами, и окружены фигурными скобками `{}`.
*
* @param is Поток ввода, из которого будет прочитано множество.
* @param ms Объект множества, в который будут записаны элементы.
*
* @return is Обновленный поток ввода.
*
* @throws MissingOpeningBraceException Если в начале ввода отсутствует открывающая фигурная скобка `{`.
* @throws InvalidCharacterException Если в процессе ввода встречаются некорректные символы.
*/




   friend istream& operator>>(istream& is, MultiSet& ms)
   {
      ms.clear();
      char ch;

      is >> ch;
      if (ch != '{')
      {
         throw MissingOpeningBraceException("в начале ввода.");
      }

      is >> ws;

      if (is.peek() == '}')
      {
         is.get();
         return is;
      }

      while (true)
      {
         int num;
         is >> num;
         ms.add(num);

         is >> ws;
         char next = is.peek();

         if (next == '}')
         {
            is.get();
            break;
         }
         else if (!isdigit(next))
         {
            is.get();
            throw InvalidCharacterException(next);
         }
      }

      ms.timsort();
      return is;
   }

};


// ==================== Часть 3. Лексический анализатор ====================

enum class TokenType {
   // Ключевые слова
   DECLARE, LET, FOR, EACH, IN, END, GOTO, WRITE, INPUT,
   EXCEPTION, SWITCH, WHEN, OTHERWISE, COMMENT,
   // Типы
   INT_TYPE, MULTISET_TYPE,
   // Общие
   VARIABLE, NUMBER,
   // Метка <<L>> (содержимое без << >>)
   LABEL,
   // Литерал мультимножества
   MULTISET_DATA,
   // Разделители/операторы
   SEMICOLON, ASSIGN, COLON, COMMA,
   OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
   // Арифметика
   PLUS, MINUS, STAR, SLASH,
   // Новые операции мультимножеств
   UNIFICATION, INTERSECTION, DIFFERENCE, SYMMETRICDIFF,
   ACCESS, CAPACITY, COMPARISON, ADDENDUM,
   // Операторы сравнения
   LESS, GREATER, LESS_EQUAL, GREATER_EQUAL, NOT_EQUAL, EQUAL,
   // Прочее
   ERROR, END_OF_FILE
};

struct Variable {
   std::string name;
   int type; // 0 = int, 1 = multiset, -1 = неизвестно
   std::variant<int, MultiSet> value;
};

struct Constant {
   std::variant<int, MultiSet> value;
};

struct Token {
   TokenType tokenType;
   int line;
   std::string text;   // для LABEL: только имя
   int constKey;       // ключ в таблице констант (для NUMBER, MULTISET_DATA)
   std::string varName; // если VARIABLE
};

struct Error {
   int line;
   std::string message;
};

struct CommentInfo {
   int line;
   std::string text;
};

static const unordered_map<string, TokenType> keywords = {
    {"declare",    TokenType::DECLARE},
    {"let",        TokenType::LET},
    {"for",        TokenType::FOR},
    {"each",       TokenType::EACH},
    {"in",         TokenType::IN},
    {"end",        TokenType::END},
    {"goto",       TokenType::GOTO},
    {"write",      TokenType::WRITE},
    {"input",      TokenType::INPUT},
    {"exception",  TokenType::EXCEPTION},
    {"switch",     TokenType::SWITCH},
    {"when",       TokenType::WHEN},
    {"otherwise",  TokenType::OTHERWISE},
    {"comment",    TokenType::COMMENT},
    {"int",        TokenType::INT_TYPE},
    {"multiset",   TokenType::MULTISET_TYPE},

    // Новые операции
    {"UNIFICATION",   TokenType::UNIFICATION},
    {"INTERSECTION",  TokenType::INTERSECTION},
    {"DIFFERENCE",    TokenType::DIFFERENCE},
    {"SYMMETRICDIFF", TokenType::SYMMETRICDIFF},
    {"ACCESS",        TokenType::ACCESS},
    {"CAPACITY",      TokenType::CAPACITY},
    {"COMPARISON",    TokenType::COMPARISON},
    {"ADDENDUM",      TokenType::ADDENDUM}
};

static const unordered_map<string, TokenType> arithOps = {
    {"+", TokenType::PLUS},
    {"-", TokenType::MINUS},
    {"*", TokenType::STAR},
    {"/", TokenType::SLASH}
};

bool isSeparatorOrOperator(char c) {
   static const unordered_set<char> seps = { '(', ')', '{', '}', ',', ':', ';', '+', '-', '*', '/', '=', '<', '>', '!' };
   return seps.count(c) > 0;
}

bool isVariableName(const string& s, string& error) {
   if (s.empty()) {
      error = "Пустая строка";
      return false;
   }
   if (!isalpha((unsigned char)s[0])) {
      error = "Имя должно начинаться с буквы";
      return false;
   }
   for (size_t i = 1; i < s.size(); i++) {
      if (!isalnum((unsigned char)s[i])) {
         error = "Недопустимые символы в имени";
         return false;
      }
   }
   return true;
}

bool isNumber(const string& s, string& error) {
   if (s.empty()) {
      error = "Пустая строка не может быть числом";
      return false;
   }
   size_t start = 0;
   if (s[0] == '+' || s[0] == '-') {
      if (s.size() == 1) {
         error = "Только знак без цифр";
         return false;
      }
      start = 1;
   }
   for (size_t i = start; i < s.size(); i++) {
      if (!isdigit((unsigned char)s[i])) {
         error = "Недопустимые символы";
         return false;
      }
   }
   return true;
}

bool isLabel(const string& s, string& labelName, string& error) {
   if (s.size() < 4) return false;
   if (s.substr(0, 2) != "<<" || s.substr(s.size() - 2) != ">>") return false;
   labelName = s.substr(2, s.size() - 4);
   if (labelName.empty()) {
      error = "Пустое имя метки";
      return false;
   }
   if (!isalpha((unsigned char)labelName[0])) {
      error = "Метка должна начинаться с буквы";
      return false;
   }
   for (size_t i = 1; i < labelName.size(); i++) {
      if (!isalnum((unsigned char)labelName[i])) {
         error = "Недопустимые символы в метке";
         return false;
      }
   }
   return true;
}

string tokenTypeToString(TokenType t) {
   switch (t) {
   case TokenType::DECLARE: return "DECLARE";
   case TokenType::LET: return "LET";
   case TokenType::FOR: return "FOR";
   case TokenType::EACH: return "EACH";
   case TokenType::IN: return "IN";
   case TokenType::END: return "END";
   case TokenType::GOTO: return "GOTO";
   case TokenType::WRITE: return "WRITE";
   case TokenType::INPUT: return "INPUT";
   case TokenType::EXCEPTION: return "EXCEPTION";
   case TokenType::SWITCH: return "SWITCH";
   case TokenType::WHEN: return "WHEN";
   case TokenType::OTHERWISE: return "OTHERWISE";
   case TokenType::COMMENT: return "COMMENT";
   case TokenType::INT_TYPE: return "INT_TYPE";
   case TokenType::MULTISET_TYPE: return "MULTISET_TYPE";
   case TokenType::VARIABLE: return "VARIABLE";
   case TokenType::NUMBER: return "NUMBER";
   case TokenType::LABEL: return "LABEL";
   case TokenType::MULTISET_DATA: return "MULTISET_DATA";
   case TokenType::SEMICOLON: return "SEMICOLON";
   case TokenType::ASSIGN: return "ASSIGN";
   case TokenType::COLON: return "COLON";
   case TokenType::COMMA: return "COMMA";
   case TokenType::OPEN_PAREN: return "OPEN_PAREN";
   case TokenType::CLOSE_PAREN: return "CLOSE_PAREN";
   case TokenType::OPEN_BRACE: return "OPEN_BRACE";
   case TokenType::CLOSE_BRACE: return "CLOSE_BRACE";
   case TokenType::PLUS: return "PLUS";
   case TokenType::MINUS: return "MINUS";
   case TokenType::STAR: return "STAR";
   case TokenType::SLASH: return "SLASH";
   case TokenType::UNIFICATION: return "UNIFICATION";
   case TokenType::INTERSECTION: return "INTERSECTION";
   case TokenType::DIFFERENCE: return "DIFFERENCE";
   case TokenType::SYMMETRICDIFF: return "SYMMETRICDIFF";
   case TokenType::ACCESS: return "ACCESS";
   case TokenType::CAPACITY: return "CAPACITY";
   case TokenType::COMPARISON: return "COMPARISON";
   case TokenType::ADDENDUM: return "ADDENDUM";
   case TokenType::LESS: return "LESS";
   case TokenType::GREATER: return "GREATER";
   case TokenType::LESS_EQUAL: return "LESS_EQUAL";
   case TokenType::GREATER_EQUAL: return "GREATER_EQUAL";
   case TokenType::NOT_EQUAL: return "NOT_EQUAL";
   case TokenType::EQUAL: return "EQUAL";
   case TokenType::ERROR: return "ERROR";
   case TokenType::END_OF_FILE: return "EOF";
   }
   return "UNKNOWN";
}

// ==================== Класс LexicalAnalyzer ====================

class LexicalAnalyzer {
private:
   vector<Token> tokens;
   vector<Error> errors;
   map<string, Variable> varTable;
   map<int, Constant> constTable;
   vector<CommentInfo> commentTable;
   int multiSetCounter = -1;
   bool inDeclaration = false;
   bool expectType = false;
   bool expectGotoLabel = false; // Флаг ожидания метки после goto

   void addError(int line, const string& msg) {
      errors.push_back({ line, msg });
   }
   void addToken(TokenType type, int line, const string& text, int constKey = -1, const string& varName = "") {
      tokens.push_back({ type, line, text, constKey, varName });
   }
   void addVariable(const string& name) {
      if (varTable.find(name) == varTable.end()) {
         Variable v;
         v.name = name;
         v.type = -1;
         v.value = 0;
         varTable[name] = v;
      }
   }
   int addIntConstant(int val) {
      if (constTable.find(val) == constTable.end()) {
         Constant c;
         c.value = val;
         constTable[val] = c;
      }
      return val;
   }
   int addMultiSetConstant(const MultiSet& ms) {
      Constant c;
      c.value = ms;
      constTable[multiSetCounter] = c;
      multiSetCounter--;
      return (multiSetCounter + 1);
   }

   // Если ожидается метка после goto, обрабатываем отдельно
   void processGotoLabel(const string& word, int& line, ifstream& file) {
      string labelName, err;
      if (isLabel(word, labelName, err)) {
         addToken(TokenType::LABEL, line, labelName);
      }
      else if (isVariableName(word, err)) {
         addToken(TokenType::LABEL, line, word);
      }
      else {
         addToken(TokenType::ERROR, line, word);
         addError(line, "Ожидалась метка после goto, а получено: " + word + ". " + err);
      }
      expectGotoLabel = false;
   }

   void processToken(const string& word, int& line, ifstream& file) {
      if (word.empty()) return;
      if (expectGotoLabel) {
         processGotoLabel(word, line, file);
         return;
      }
      if (word == "goto") {
         addToken(TokenType::GOTO, line, word);
         expectGotoLabel = true;
         return;
      }
      if (inDeclaration) {
         if (!expectType) {
            string err;
            if (!isVariableName(word, err)) {
               addToken(TokenType::ERROR, line, word);
               addError(line, "Некорректное имя переменной: " + word + ". " + err);
            }
            else {
               addVariable(word);
               addToken(TokenType::VARIABLE, line, word, -1, word);
               expectType = true;
            }
            return;
         }
         else {
            auto itKw = keywords.find(word);
            if (itKw != keywords.end()) {
               TokenType ttype = itKw->second;
               if (ttype == TokenType::INT_TYPE || ttype == TokenType::MULTISET_TYPE) {
                  addToken(ttype, line, word);
                  expectType = false;
                  return;
               }
               else {
                  addToken(TokenType::ERROR, line, word);
                  addError(line, "Ожидался тип (int/multiset), а встретилось: " + word);
                  expectType = false;
                  return;
               }
            }
            else {
               addToken(TokenType::ERROR, line, word);
               addError(line, "Ожидался тип (int/multiset), а встретилось: " + word);
               expectType = false;
               return;
            }
         }
      }
      {
         string labelName, err;
         if (isLabel(word, labelName, err)) {
            addToken(TokenType::LABEL, line, labelName);
            return;
         }
      }
      auto itKw = keywords.find(word);
      if (itKw != keywords.end()) {
         TokenType ttype = itKw->second;
         if (ttype == TokenType::DECLARE) {
            inDeclaration = true;
            expectType = false;
         }
         if (ttype == TokenType::COMMENT) {
            addToken(ttype, line, word);
            string commentText;
            while (!file.eof()) {
               char c = file.peek();
               if (c == ';') break;
               c = file.get();
               if (!file.good()) break;
               if (c == '\n') line++;
               commentText.push_back(c);
            }
            commentTable.push_back({ line, commentText });
            return;
         }
         addToken(ttype, line, word);
         return;
      }
      {
         string err;
         if (isNumber(word, err)) {
            int val = stoi(word);
            int key = addIntConstant(val);
            addToken(TokenType::NUMBER, line, word, key);
            return;
         }
      }
      {
         string err;
         if (isVariableName(word, err)) {
            addVariable(word);
            addToken(TokenType::VARIABLE, line, word, -1, word);
            return;
         }
         else {
            addToken(TokenType::ERROR, line, word);
            addError(line, "Неизвестный/некорректный токен: " + word + ". " + err);
            return;
         }
      }
   }

   void processSeparatorOrOperator(char c, int& line, ifstream& file) {
      // Обработка метки, если встретили "<<" (начало метки)
      if (c == '<') {
         char next = file.peek();
         if (next == '<') {
            file.get();
            string labelToken = "";
            while (!file.eof()) {
               char d = file.get();
               if (d == '>') {
                  char d2 = file.peek();
                  if (d2 == '>') {
                     file.get();
                     break;
                  }
                  else {
                     labelToken.push_back(d);
                  }
               }
               else {
                  labelToken.push_back(d);
               }
            }
            addToken(TokenType::LABEL, line, labelToken);
            return;
         }
      }
      // Обработка операторов сравнения
      if (c == '<' || c == '>' || c == '!' || c == '=') {
         char next = file.peek();
         if (c == '<') {
            if (next == '=') {
               file.get();
               addToken(TokenType::LESS_EQUAL, line, "<=");
            }
            else {
               addToken(TokenType::LESS, line, "<");
            }
            return;
         }
         if (c == '>') {
            if (next == '=') {
               file.get();
               addToken(TokenType::GREATER_EQUAL, line, ">=");
            }
            else {
               addToken(TokenType::GREATER, line, ">");
            }
            return;
         }
         if (c == '!') {
            if (next == '=') {
               file.get();
               addToken(TokenType::NOT_EQUAL, line, "!=");
            }
            else {
               addToken(TokenType::ERROR, line, "!");
               addError(line, "Оператор '!' должен быть за которым следует '='");
            }
            return;
         }
         if (c == '=') {
            if (next == '=') {
               file.get();
               addToken(TokenType::EQUAL, line, "==");
            }
            else {
               addToken(TokenType::ASSIGN, line, "=");
            }
            return;
         }
      }
      // Обработка мультимножества
      if (c == '{') {
         file.unget();
         try {
            MultiSet ms;
            // Используем функцию readFromFile() из класса MultiSet для считывания
            ms.readFromFile(file);
            int key = addMultiSetConstant(ms);
            addToken(TokenType::MULTISET_DATA, line, "{...}", key);
         }
         catch (const exception& e) {
            addToken(TokenType::ERROR, line, "{...}");
            addError(line, string("Ошибка при чтении MultiSet: ") + e.what());
            while (!file.eof() && file.peek() != '\n') {
               file.get();
            }
         }
         return;
      }
      if (c == ';') {
         if (inDeclaration && expectType) {
            addError(line, "Ожидался тип, а встретили ';'.");
            expectType = false;
         }
         if (inDeclaration) {
            inDeclaration = false;
         }
         addToken(TokenType::SEMICOLON, line, ";");
         return;
      }
      if (c == ',') {
         if (inDeclaration) {
            if (expectType) {
               addError(line, "Ожидался тип, а встретили ','.");
            }
            expectType = false;
         }
         addToken(TokenType::COMMA, line, ",");
         return;
      }
      switch (c) {
      case ':': addToken(TokenType::COLON, line, ":"); break;
      case '(': addToken(TokenType::OPEN_PAREN, line, "("); break;
      case ')': addToken(TokenType::CLOSE_PAREN, line, ")"); break;
      case '}': addToken(TokenType::CLOSE_BRACE, line, "}"); break;
      case '+': case '-': case '*': case '/': {
         string op(1, c);
         auto itOp = arithOps.find(op);
         if (itOp != arithOps.end()) {
            addToken(itOp->second, line, op);
         }
         else {
            addToken(TokenType::ERROR, line, op);
            addError(line, "Неизвестный оператор: " + op);
         }
         break;
      }
      default:
         addToken(TokenType::ERROR, line, string(1, c));
         addError(line, "Неизвестный символ: " + string(1, c));
      }
   }

public:
   void analyze(const string& filename) {
      tokens.clear();
      errors.clear();
      varTable.clear();
      constTable.clear();
      commentTable.clear();
      multiSetCounter = -1;
      inDeclaration = false;
      expectType = false;
      expectGotoLabel = false;

      ifstream file(filename);
      if (!file.is_open()) {
         throw runtime_error("Не удалось открыть файл: " + filename);
      }
      int line = 1;
      char ch;
      string buffer;
      while (true) {
         file.get(ch);
         if (file.eof()) {
            if (!buffer.empty()) {
               processToken(buffer, line, file);
               buffer.clear();
            }
            break;
         }
         if (ch == '\n') {
            if (!buffer.empty()) {
               processToken(buffer, line, file);
               buffer.clear();
            }
            line++;
         }
         else if (isspace((unsigned char)ch)) {
            if (!buffer.empty()) {
               processToken(buffer, line, file);
               buffer.clear();
            }
         }
         else if (isSeparatorOrOperator(ch)) {
            if (!buffer.empty()) {
               processToken(buffer, line, file);
               buffer.clear();
            }
            processSeparatorOrOperator(ch, line, file);
         }
         else {
            buffer.push_back(ch);
         }
      }
      addToken(TokenType::END_OF_FILE, line, "EOF");
      file.close();
   }

   void printTokens() const {
      cout << "\n=== TOKENS ===\n";
      for (const auto& tk : tokens) {
         cout << "[" << tk.line << "] " << setw(15) << tokenTypeToString(tk.tokenType)
            << " : " << tk.text;
         if (tk.constKey != -1)
            cout << " (constKey=" << tk.constKey << ")";
         if (!tk.varName.empty())
            cout << " (varName=" << tk.varName << ")";
         cout << "\n";
      }
   }

   void printErrors() const {
      if (errors.empty()) {
         cout << "\nНет ошибок лексического анализа.\n";
         return;
      }
      cout << "\n=== ERRORS ===\n";
      for (const auto& e : errors)
         cout << "[Line " << e.line << "] " << e.message << "\n";
   }

   void printVarTable() const {
      cout << "\n=== VAR TABLE ===\n";
      for (const auto& kv : varTable)
         cout << "  " << kv.first << " (type=" << kv.second.type << ")\n";
   }

   void printConstTable() const {
      cout << "\n=== CONST TABLE ===\n";
      for (const auto& kv : constTable) {
         cout << " Key=" << kv.first << " => ";
         if (holds_alternative<int>(kv.second.value))
            cout << get<int>(kv.second.value) << " (int)";
         else
            cout << get<MultiSet>(kv.second.value) << " (multiset)";
         cout << "\n";
      }
   }

   void printCommentTable() const {
      cout << "\n=== COMMENT TABLE ===\n";
      for (const auto& c : commentTable)
         cout << " [Line " << c.line << "] " << c.text << "\n";
   }
};



int main() {
   setlocale(LC_ALL, "Russian");

   /*
   Пример входного файла (input.2xlvi):

   comment Полный тестовый пример для языка LXLVI;

   declare a int, b multiset, c int;
   let a = 10;
   let b = {2 3 3 4};
   let c = a + 5;

   for each i in b;
       write i;
       let a = a - 1;
   end;

   switch a;
       when 14: write a;
       otherwise: write b;
   end;

   UNIFICATION b b;
   INTERSECTION b b;
   DIFFERENCE b b;
   SYMMETRICDIFF b b;
   ACCESS b a;
   CAPACITY b;
   COMPARISON a b;
   ADDENDUM b a;

   <<MainLoop>>
   goto MainLoop;
   let x = 5;    // оператор присваивания: let V = E;
   a < 100;
   b >= 50;
   a != 0;
   a == 10;
   end;
   */

   LexicalAnalyzer analyzer;
   try {
      analyzer.analyze("out.txt");
   }
   catch (const exception& e) {
      cerr << "Ошибка: " << e.what() << endl;
      return 1;
   }
   analyzer.printTokens();
   analyzer.printErrors();
   analyzer.printVarTable();
   analyzer.printConstTable();
   analyzer.printCommentTable();


   return 0;
}
